* API Server Initialization and Lifecycle
:PROPERTIES:
:TOC: :include descendants
:END:

:CONTENTS:
- [[#concepts-and-purpose][Concepts and purpose]]
  - [[#application-entry-point][Application entry point]]
  - [[#worker-and-event-processing][Worker and event processing]]
  - [[#graceful-shutdown-mechanism][Graceful shutdown mechanism]]
- [[#design-and-implementation][Design and implementation]]
  - [[#command-line-flags][Command line flags]]
  - [[#logger-initialization][Logger initialization]]
  - [[#observability-setup][Observability setup]]
  - [[#event-queue-and-worker-initialization][Event queue and worker initialization]]
  - [[#server-configuration-and-validation][Server configuration and validation]]
  - [[#server-initialization-and-startup][Server initialization and startup]]
  - [[#graceful-shutdown-implementation][Graceful shutdown implementation]]
- [[#usage-examples][Usage examples]]
  - [[#command-line-execution][Command line execution]]
  - [[#handling-background-tasks][Handling background tasks]]
  - [[#shutdown-hook-registration][Shutdown hook registration]]
:END:

** Concepts and purpose

*** Application entry point

- Application entry point :: The `Main` function serves as the entry point for the API server application. It is responsible for:
  - Initializing core components :: Setting up the logger, OpenTelemetry, and Prometheus metrics
  - Creating the event queue and worker :: Setting up the event processing pipeline
  - Configuring the server :: Creating and validating the API server configuration
  - Starting the HTTP server :: Launching the server with the appropriate protocol (HTTP/HTTPS)
  - Handling shutdown :: Ensuring graceful termination when the application receives shutdown signals
  The entry point coordinates all aspects of the application lifecycle from startup to shutdown, ensuring proper resource initialization and cleanup.

*** Worker and event processing

- Event processing pipeline :: The application includes an event processing system that:
  - Provides an event queue :: For buffering events before processing
  - Runs a worker process :: To consume and process events asynchronously
  - Integrates with metrics :: For monitoring queue and worker performance
  - Handles graceful shutdown :: To ensure all events are processed before termination
  This event processing system enables asynchronous handling of various event types with proper monitoring and error handling.

*** Graceful shutdown mechanism

- Graceful shutdown :: The API server implements a graceful shutdown mechanism that:
  - Captures termination signals :: Listens for SIGTERM, SIGINT, and SIGQUIT signals
  - Executes shutdown functions :: Runs all registered shutdown functions in sequence, including server and worker shutdown
  - Waits for background tasks :: Ensures all background tasks complete before termination
  - Provides status reporting :: Reports successful or failed shutdown via a channel
  This mechanism ensures that the server closes active connections properly, completes in-flight requests, processes remaining events, and releases all resources before termination.

** Design and implementation

*** Command line flags

- Command line parameters :: The application uses command line flags to configure its behavior
  | ~CmdLogLevelFlag~        | Logging level for the application |
  | ~CmdHTTPSrvListenAddr~   | HTTP server listen address and port |
  | ~CmdHTTPSrvReadTimeout~  | Maximum time allowed to read client request |
  | ~CmdHTTPSrvWriteTimeout~ | Maximum time allowed to write response |
  | ~CmdHTTPSrvIdleTimeout~  | Maximum time connection can be idle |
  | ~CmdTlsCertFile~         | Path to TLS certificate file |
  | ~CmdTlsKeyFile~          | Path to TLS key file |
  | ~CmdGlobalRateLimit~     | Maximum global requests per second |
  | ~CmdPerClientRateLimit~  | Maximum requests per second per client |
  | ~CmdEnableRateLimit~     | Flag to enable/disable rate limiting |
  #+BEGIN_SRC go
var (
	CmdLogLevelFlag        string
	CmdHTTPSrvListenAddr   string
	CmdHTTPSrvReadTimeout  time.Duration
	CmdHTTPSrvWriteTimeout time.Duration
	CmdHTTPSrvIdleTimeout  time.Duration
	CmdTlsCertFile         string
	CmdTlsKeyFile          string
	CmdGlobalRateLimit     int64
	CmdPerClientRateLimit  int64
	CmdEnableRateLimit     bool
)
  #+END_SRC

*** Logger initialization

- Logger setup :: Initializes a structured logger with the appropriate log level
  - Configures stack traces for error logging when needed
  - Sets the log level based on command line flags
  - Adds timestamps to all log entries
  #+BEGIN_SRC go
// initializing the logger with respect to the specified loglevel option
var nlogger zerolog.Logger
zerolog.ErrorStackMarshaler = pkgerrors.MarshalStack
if zerolog.LevelTraceValue == CmdLogLevelFlag {
	nlogger = zerolog.New(os.Stdout).With().Stack().Timestamp().Logger().Level(zerolog.TraceLevel)
} else {
	loglvl, _ := zerolog.ParseLevel(CmdLogLevelFlag)
	nlogger = zerolog.New(os.Stdout).With().Timestamp().Logger().Level(loglvl)
}
  #+END_SRC

*** Observability setup

- Observability initialization :: Sets up OpenTelemetry and Prometheus for monitoring and tracing
  - Configures Jaeger for distributed tracing
  - Sets up Prometheus metrics collection
  - Returns a shutdown function for clean resource release
  #+BEGIN_SRC go
// initialize opentelemetry
otelShut, err := observ.SetupOTelSDK(ctx, observ.CmdJaegerHostFlag, observ.CmdJaegerPortFlag, observ.CmdJaegerConnectionTimeout, observ.CmdSpanExportInterval)
if err != nil {
	nlogger.Error().Err(err).Msg("failed to initialize the opentelemetry sdk")
	return
}
  #+END_SRC

*** Event queue and worker initialization

- Event queue and worker setup :: Creates and initializes the event queue and worker components
  - Creates a new event queue for buffering events
  - Initializes the models structure with the event queue
  - Creates a new worker instance for processing events
  - Starts the worker in a background goroutine
  - Initializes Prometheus metrics with the event queue
  #+BEGIN_SRC go
// initialize the models so apiServer can have access to the models and eventQueue system
eq := data.NewEventQueue()
nModel := data.NewModels(eq, nil, nil)

// initialize and run worker node
nWorker := worker.NewWorker(&nlogger, eq, ctx)
helpers.BackgroundJob(func() {
	nWorker.Run(ctx)
}, &nlogger, "new worker paniced during consuming events")

// initialize the prometheus
observ.PromInit(eq, Version)
  #+END_SRC

*** Server configuration and validation

- Configuration and validation :: Creates and validates the API server configuration
  - Parses the listen address URL
  - Creates a new API server configuration
  - Validates all configuration parameters
  - Logs and exits on validation errors
  #+BEGIN_SRC go
// initializing new validator to be used for input validation of cmdOptions
nVal := helpers.NewValidator()

// parsing the listen address
url, err := url.Parse(CmdHTTPSrvListenAddr)
if err != nil {
	nlogger.Error().Err(err).Send()
	return
}

nApiCfg := NewApiServerCfg(url, CmdTlsCertFile,
	CmdTlsKeyFile,
	CmdEnableRateLimit,
	CmdGlobalRateLimit,
	CmdPerClientRateLimit,
	CmdHTTPSrvReadTimeout,
	CmdHTTPSrvIdleTimeout,
	CmdHTTPSrvWriteTimeout)
if !nApiCfg.validation(*nVal).Valid() {
	for key, err := range nVal.Errors {
		err := fmt.Errorf("%s is invalid: %s", key, err)
		nlogger.Error().Err(err).Send()
	}
	return
}
  #+END_SRC

*** Server initialization and startup

- Server creation and startup :: Initializes and starts the HTTP server
  - Creates the API server instance with models
  - Configures the HTTP server with appropriate timeouts
  - Sets up routes and handlers
  - Starts graceful shutdown handler including worker shutdown
  - Starts the server with TLS if HTTPS is configured
  - Logs server startup information
  #+BEGIN_SRC go
nApi := NewApiServer(nApiCfg, &nlogger, nModel)
nSrv := http.Server{
	Addr:         nApi.Cfg.ListenAddr.Host,
	Handler:      nApi.routes(),
	ReadTimeout:  nApi.Cfg.ServerReadTimeout,
	WriteTimeout: nApi.Cfg.ServerWriteTimeout,
	IdleTimeout:  nApi.Cfg.ServerIdleTimeout,
	ErrorLog:     log.New(nApi.Logger, "", 0),
}

shutdownChan := make(chan error)
go gracefulShutdown(nApi, &nlogger, shutdownChan, nSrv.Shutdown, nWorker.Shutdown, otelShut)

if nApi.Cfg.ListenAddr.Scheme == "https" {
	nlogger.Info().Msgf("starting the server on %s over %s", nApi.Cfg.ListenAddr.Host, nApi.Cfg.ListenAddr.Scheme)
	err := nSrv.ListenAndServeTLS(nApi.Cfg.TlsCertFile, nApi.Cfg.TlsKeyFile)
	if err != nil && err != http.ErrServerClosed {
		nlogger.Error().Err(err).Send()
		return
	}
} else {
	nlogger.Info().Msgf("starting the server on %s over %s", nApi.Cfg.ListenAddr.Host, nApi.Cfg.ListenAddr.Scheme)
	err := nSrv.ListenAndServe()
	if err != nil && err != http.ErrServerClosed {
		nlogger.Error().Err(err).Send()
		return
	}
}

err = <-shutdownChan
if err != nil {
	nlogger.Error().Err(err).Send()
}
  #+END_SRC

*** Graceful shutdown implementation

- Graceful shutdown process :: The `gracefulShutdown` function handles clean server termination
  - Sets up a signal channel to catch OS termination signals
  - Logs when a termination signal is received
  - Creates a timeout context for shutdown operations
  - Executes all registered shutdown functions including worker shutdown
  - Waits for background tasks to complete
  - Signals successful or failed shutdown via a channel
  #+BEGIN_SRC go
func gracefulShutdown(api *ApiServer, logger *zerolog.Logger, shutdownChan chan error, shutdownFuncs ...func(context.Context) error) {
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGTERM, syscall.SIGINT, syscall.SIGQUIT)
	s := <-sigChan

	// log the signal catched
	logger.Warn().Msgf("catched os signal %s", s)

	// gracefully shutdown the services
	ctx, cancel := context.WithTimeout(context.Background(), time.Second*20)
	defer cancel()

	for _, shutdownFunc := range shutdownFuncs {
		err := shutdownFunc(ctx)
		if err != nil {
			shutdownChan <- err
		}
	}

	// waiting for the background tasks to finish
	logger.Info().Msg("waiting for background tasks to finish")
	api.Wg.Wait()

	shutdownChan <- nil

	logger.Info().Msg("stopped the server")
}
  #+END_SRC

** Usage examples

*** Command line execution

Example of running the application with command line flags:

#+BEGIN_SRC sh
# Run with default settings
./myapp serve

# Run with custom settings
./myapp serve \
  --log-level=info \
  --http-listen-addr=:8081 \
  --read-timeout=5s \
  --write-timeout=10s \
  --idle-timeout=120s \
  --enable-rate-limit \
  --global-rate-limit=100 \
  --per-client-rate-limit=10
#+END_SRC

*** Handling background tasks

Example of running background tasks with proper tracking:

#+BEGIN_SRC go
package main

import (
	"github.com/cybrarymin/behavox/api"
	"github.com/cybrarymin/behavox/internal"
	"github.com/rs/zerolog"
)

func runBackgroundTask(logger *zerolog.Logger, api *api.ApiServer) {
	// Register the task with the wait group
	api.Wg.Add(1)
	
	// Run the task in a goroutine
	go func() {
		// Ensure the wait group is decremented when done
		defer api.Wg.Done()
		
		// Task logic here
		// ...
		
		logger.Info().Msg("Background task completed")
	}()
}

// Using the helper function to run a background job with panic recovery
func safeBackgroundTask(logger *zerolog.Logger) {
	internal.BackgroundJob(func() {
		// Task logic here
		// ...
	}, logger, "background task panicked")
}
#+END_SRC

*** Shutdown hook registration

Example of registering shutdown hooks:

#+BEGIN_SRC go
package main

import (
	"context"
	"fmt"
	"time"
	
	"github.com/cybrarymin/behavox/api"
)

func registerShutdownHooks() {
	// Define shutdown functions that implement the required signature
	httpServerShutdown := func(ctx context.Context) error {
		fmt.Println("Shutting down HTTP server...")
		// Close connections, etc.
		return nil
	}
	
	databaseShutdown := func(ctx context.Context) error {
		fmt.Println("Closing database connections...")
		// Close database connections
		time.Sleep(100 * time.Millisecond) // Simulate work
		return nil
	}
	
	cacheShutdown := func(ctx context.Context) error {
		fmt.Println("Flushing cache...")
		// Flush cache to persistent storage
		return nil
	}
	
	// In the real application, these would be passed to gracefulShutdown
	// For example:
	// go gracefulShutdown(api, logger, shutdownChan, httpServerShutdown, databaseShutdown, cacheShutdown)
}
#+END_SRC