* API Server
:PROPERTIES:
:TOC: :include descendants
:END:

:CONTENTS:
- [[#concepts-and-purpose][Concepts and purpose]]
  - [[#api-server-configuration][API server configuration]]
  - [[#request-context-management][Request context management]]
  - [[#event-handling-integration][Event handling integration]]
- [[#design-and-implementation][Design and implementation]]
  - [[#api-server-configuration-structure][API server configuration structure]]
  - [[#api-server-structure][API server structure]]
  - [[#configuration-validation][Configuration validation]]
  - [[#request-context-handling][Request context handling]]
  - [[#models-integration][Models integration]]
- [[#usage-examples][Usage examples]]
  - [[#creating-and-configuring-the-api-server][Creating and configuring the API server]]
  - [[#handling-request-context][Handling request context]]
  - [[#working-with-events][Working with events]]
  - [[#complete-server-initialization][Complete server initialization]]
:END:

** Concepts and purpose

*** API server configuration

- API server configuration :: The API server configuration provides necessary parameters for HTTP/HTTPS serving, connection handling, TLS settings, and rate limiting. The configuration holds settings that control:
  - Server address and protocol :: The address and protocol (HTTP/HTTPS) used by the server
  - Connection timeouts :: Read, write, and idle timeouts to prevent resource exhaustion
  - TLS settings :: Certificate and key file paths for HTTPS serving
  - Rate limiting :: Global and per-client rate limiting settings to prevent abuse
  These configuration parameters enable fine-tuning of the server's behavior to meet performance and security requirements.

*** Request context management

- Request context :: Each API request is assigned a unique request ID stored in the request context, enabling:
  - Request tracing :: The ability to track a request through the system for debugging
  - Correlation :: Linking logs, metrics, and traces to specific requests
  - Observability :: Enhanced monitoring and troubleshooting capabilities
  The request ID is a UUID generated for each incoming request and made available to all handlers and middleware in the request processing chain.

*** Event handling integration

- Event processing :: The API server integrates with an event processing system that:
  - Provides access to event queue :: Through the Models structure
  - Enables event publishing :: Allowing HTTP handlers to queue events for processing
  - Promotes decoupling :: HTTP request handling is decoupled from event processing
  - Supports asynchronous operations :: Long-running tasks can be processed outside the request-response cycle
  This integration enables a more scalable and resilient architecture for handling operations that don't need to be completed within the HTTP request lifecycle.

** Design and implementation

*** API server configuration structure

- API server configuration :: The `ApiServerCfg` struct defines all necessary settings for running the API server
  | ~ListenAddr *url.URL~       | URL containing address and protocol for server to listen on |
  | ~ServerReadTimeout~         | Maximum time allowed to read client request bodies |
  | ~ServerWriteTimeout~        | Maximum time allowed to write a response to the client |
  | ~ServerIdleTimeout~         | Maximum time connection can be idle before closing |
  | ~TlsCertFile~               | Path to TLS certificate file for HTTPS serving |
  | ~TlsKeyFile~                | Path to TLS key file for HTTPS serving |
  | ~RateLimit~                 | Nested struct containing rate limiting settings |
  | ~RateLimit.GlobalRateLimit~ | Maximum requests per second for entire server |
  | ~RateLimit.perClientRateLimit~ | Maximum requests per second per client IP |
  | ~RateLimit.Enabled~         | Flag to enable/disable rate limiting |
  #+BEGIN_SRC go
type ApiServerCfg struct {
	ListenAddr         *url.URL      // http server listen address url
	ServerReadTimeout  time.Duration // amount of time allowed to read a request body otherwise server will return an error
	ServerWriteTimeout time.Duration // amount of time allowed to write a response for the client
	ServerIdleTimeout  time.Duration // amount of time in idle mode before closing the connection with client
	TlsCertFile        string        // Tls certificate file for https serving
	TlsKeyFile         string        // Tls key file https serving
	RateLimit          struct {
		GlobalRateLimit    int64
		perClientRateLimit int64
		Enabled            bool
	}
}
  #+END_SRC

- Configuration factory :: The `NewApiServerCfg` function creates and initializes a properly configured `ApiServerCfg` instance
  #+BEGIN_SRC go
func NewApiServerCfg(listenAddr *url.URL, tlsCertFile string, tlsKeyFile string, rateLimitEnabled bool, globalRateLimit int64, perCleintRateLimit int64, srvReadTimeout, srvIdleTimeout, srvWriteTimeout time.Duration) *ApiServerCfg {
	return &ApiServerCfg{
		ListenAddr:         listenAddr,
		ServerReadTimeout:  srvReadTimeout,
		ServerWriteTimeout: srvWriteTimeout,
		ServerIdleTimeout:  srvIdleTimeout,
		TlsCertFile:        tlsCertFile,
		TlsKeyFile:         tlsKeyFile,
		RateLimit: struct {
			GlobalRateLimit    int64
			perClientRateLimit int64
			Enabled            bool
		}{
			GlobalRateLimit:    globalRateLimit,
			Enabled:            rateLimitEnabled,
			perClientRateLimit: perCleintRateLimit,
		},
	}
}
  #+END_SRC

*** API server structure

- API server :: The `ApiServer` struct encapsulates the server's state and dependencies
  | ~Cfg *ApiServerCfg~     | Reference to server configuration |
  | ~Logger *zerolog.Logger~ | Structured logger for recording server events |
  | ~Wg sync.WaitGroup~     | Wait group for coordinating goroutines |
  | ~mu sync.RWMutex~       | Read-write mutex for thread-safe operations |
  | ~models *data.Models~   | Reference to data models including event queue |
  #+BEGIN_SRC go
type ApiServer struct {
	Cfg    *ApiServerCfg
	Logger *zerolog.Logger
	Wg     sync.WaitGroup
	mu     sync.RWMutex
	models *data.Models
}
  #+END_SRC

- Server factory :: The `NewApiServer` function creates a new `ApiServer` instance with the given configuration, logger, and models
  #+BEGIN_SRC go
func NewApiServer(cfg *ApiServerCfg, logger *zerolog.Logger, models *data.Models) *ApiServer {
	return &ApiServer{
		Cfg:    cfg,
		Logger: logger,
		models: models,
	}
}
  #+END_SRC

*** Configuration validation

- Configuration validation :: The `validation` method checks the configuration for validity
  - Verifies that the URL scheme is either "http" or "https"
  - For HTTPS, checks that certificate and key files exist
  - Returns an updated validator with any validation errors
  #+BEGIN_SRC go
func (cfg *ApiServerCfg) validation(nVal helpers.Validator) *helpers.Validator {
	nVal.Check(cfg.ListenAddr.Scheme == "http" || cfg.ListenAddr.Scheme == "https", "listen-addr", "invalid schema")
	if cfg.ListenAddr.Scheme == "https" {
		_, err := os.Stat(cfg.TlsCertFile)
		nVal.Check(err == nil, "tls-certfile", fmt.Sprintf("%s doesn't exists", cfg.TlsCertFile))
		_, err = os.Stat(cfg.TlsKeyFile)
		nVal.Check(err == nil, "tls-key", fmt.Sprintf("%s doesn't exists", cfg.TlsKeyFile))
	}
	return &nVal
}
  #+END_SRC

*** Request context handling

- Request context key :: A constant defining the key used to store and retrieve the request ID in the context
  #+BEGIN_SRC go
type contextKey string

const RequestContextKey = contextKey("request_id")
  #+END_SRC

- Setting request ID :: The `setReqIDContext` method generates a unique UUID for each request and adds it to the request context
  #+BEGIN_SRC go
func (api *ApiServer) setReqIDContext(r *http.Request) *http.Request {
	reqId := uuid.New()
	nCtx := context.WithValue(r.Context(), RequestContextKey, reqId.String())
	r = r.WithContext(nCtx)
	return r
}
  #+END_SRC

- Getting request ID :: The `getReqIDContext` method retrieves the request ID from the request context
  #+BEGIN_SRC go
func (api *ApiServer) getReqIDContext(r *http.Request) string {
	reqID := r.Context().Value(RequestContextKey)
	return reqID.(string)
}
  #+END_SRC

*** Models integration

- Models access :: The API server provides access to data models and event queue
  - Models structure containing the event queue
  - API handlers can access models to enqueue events
  - Promotes separation of concerns between request handling and event processing
  #+BEGIN_SRC go
// Example of a handler using the models to enqueue an event
func (api *ApiServer) createEventHandler(w http.ResponseWriter, r *http.Request) {
	// Create a new event
	event := data.NewEventLog(
		uuid.New().String(),
		"info",
		"Event created via API",
	)
	
	// Enqueue the event for processing
	err := api.models.EventQueue.PutEvent(r.Context(), event)
	if err != nil {
		// Handle error (e.g., queue full)
		http.Error(w, "Failed to queue event", http.StatusServiceUnavailable)
		return
	}
	
	// Respond with success
	w.WriteHeader(http.StatusAccepted)
	w.Write([]byte(`{"status":"event queued for processing"}`))
}
  #+END_SRC

** Usage examples

*** Creating and configuring the API server

Example of creating and configuring the API server:

#+BEGIN_SRC go
package main

import (
    "net/url"
    "os"
    "time"
    
    "github.com/cybrarymin/behavox/api"
    "github.com/cybrarymin/behavox/internal/models"
    "github.com/rs/zerolog"
)

func main() {
    // Create a logger
    logger := zerolog.New(os.Stdout).With().Timestamp().Logger()
    
    // Parse the listen address
    listenURL, _ := url.Parse("http://localhost:8080")
    
    // Create the API server configuration
    cfg := api.NewApiServerCfg(
        listenURL,                  // Listen address
        "",                         // TLS cert file (empty for HTTP)
        "",                         // TLS key file (empty for HTTP)
        true,                       // Enable rate limiting
        100,                        // Global rate limit: 100 requests/second
        10,                         // Per-client rate limit: 10 requests/second
        time.Second*10,             // Read timeout
        time.Second*120,            // Idle timeout
        time.Second*10,             // Write timeout
    )
    
    // Create event queue and models
    eventQueue := models.NewEventQueue()
    appModels := models.NewModels(eventQueue, nil, nil)
    
    // Create the API server
    server := api.NewApiServer(cfg, &logger, appModels)
    
    // Server is now ready for route configuration and startup
}
#+END_SRC

*** Handling request context

Example of using the request context in a handler:

#+BEGIN_SRC go
package main

import (
    "net/http"
    
    "github.com/cybrarymin/behavox/api"
)

func main() {
    // ... server initialization from previous example ...
    
    // Example handler that uses the request ID
    logRequestHandler := func(w http.ResponseWriter, r *http.Request) {
        // Get request ID from context
        requestID := server.getReqIDContext(r)
        
        // Log with request ID
        server.Logger.Info().
            Str("request_id", requestID).
            Str("path", r.URL.Path).
            Msg("Handling request")
        
        // Handle the request
        w.Write([]byte("Request processed successfully"))
    }
    
    // Create a wrapped handler that ensures request ID is set
    wrappedHandler := server.setContextHandler(http.HandlerFunc(logRequestHandler))
    
    // Register the handler
    http.Handle("/api/example", wrappedHandler)
}
#+END_SRC

*** Working with events

Example of creating and processing events:

#+BEGIN_SRC go
package main

import (
    "net/http"
    "context"
    
    "github.com/cybrarymin/behavox/api"
    "github.com/cybrarymin/behavox/internal/models"
    "github.com/google/uuid"
)

func registerEventHandlers(server *api.ApiServer) {
    // Handler for creating log events
    http.HandleFunc("/api/events/log", func(w http.ResponseWriter, r *http.Request) {
        // Parse request parameters
        level := r.URL.Query().Get("level")
        message := r.URL.Query().Get("message")
        
        if level == "" || message == "" {
            http.Error(w, "Missing required parameters", http.StatusBadRequest)
            return
        }
        
        // Create log event
        logEvent := models.NewEventLog(
            uuid.New().String(),
            level,
            message,
        )
        
        // Add event to queue
        err := server.models.EventQueue.PutEvent(r.Context(), logEvent)
        if err != nil {
            http.Error(w, "Failed to queue event: "+err.Error(), http.StatusInternalServerError)
            return
        }
        
        // Respond with success
        w.Header().Set("Content-Type", "application/json")
        w.Write([]byte(`{"status":"success","message":"Event queued for processing"}`))
    })
    
    // Handler for creating metric events
    http.HandleFunc("/api/events/metric", func(w http.ResponseWriter, r *http.Request) {
        // Parse value parameter
        valueStr := r.URL.Query().Get("value")
        if valueStr == "" {
            http.Error(w, "Missing value parameter", http.StatusBadRequest)
            return
        }
        
        value, err := strconv.ParseFloat(valueStr, 64)
        if err != nil {
            http.Error(w, "Invalid value format", http.StatusBadRequest)
            return
        }
        
        // Create metric event
        metricEvent := models.NewEventMetric(
            uuid.New().String(),
            value,
        )
        
        // Add event to queue
        err = server.models.EventQueue.PutEvent(r.Context(), metricEvent)
        if err != nil {
            http.Error(w, "Failed to queue event: "+err.Error(), http.StatusInternalServerError)
            return
        }
        
        // Respond with success
        w.Header().Set("Content-Type", "application/json")
        w.Write([]byte(`{"status":"success","message":"Metric event queued for processing"}`))
    })
}
#+END_SRC

*** Complete server initialization

Example of a complete server initialization with event processing:

#+BEGIN_SRC go
package main

import (
    "context"
    "log"
    "net/http"
    "net/url"
    "os"
    "os/signal"
    "syscall"
    "time"
    
    "github.com/cybrarymin/behavox/api"
    "github.com/cybrarymin/behavox/api/observability"
    "github.com/cybrarymin/behavox/internal/models"
    "github.com/cybrarymin/behavox/worker"
    "github.com/rs/zerolog"
)

func main() {
    // Initialize context
    ctx := context.Background()
    
    // Initialize logger
    logger := zerolog.New(os.Stdout).With().Timestamp().Logger()
    
    // Create event queue
    models.CmdEventQueueSize = 100
    eventQueue := models.NewEventQueue()
    appModels := models.NewModels(eventQueue, nil, nil)
    
    // Initialize worker
    worker.CmdProcessedEventFile = "processed_events.json"
    workerInstance := worker.NewWorker(&logger, eventQueue, ctx)
    
    // Start worker in background
    go workerInstance.Run(ctx)
    
    // Initialize observability
    observ.PromInit(eventQueue, "1.0.0")
    
    // Create server configuration
    listenURL, _ := url.Parse("http://localhost:8080")
    cfg := api.NewApiServerCfg(
        listenURL,
        "",
        "",
        true,
        100,
        10,
        time.Second*10,
        time.Second*120,
        time.Second*10,
    )
    
    // Create API server
    server := api.NewApiServer(cfg, &logger, appModels)
    
    // Configure HTTP server
    httpServer := &http.Server{
        Addr:         cfg.ListenAddr.Host,
        Handler:      server.routes(),
        ReadTimeout:  cfg.ServerReadTimeout,
        WriteTimeout: cfg.ServerWriteTimeout,
        IdleTimeout:  cfg.ServerIdleTimeout,
    }
    
    // Start HTTP server
    go func() {
        logger.Info().Str("addr", httpServer.Addr).Msg("Starting HTTP server")
        if err := httpServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            logger.Fatal().Err(err).Msg("HTTP server error")
        }
    }()
    
    // Wait for shutdown signal
    stop := make(chan os.Signal, 1)
    signal.Notify(stop, syscall.SIGINT, syscall.SIGTERM)
    <-stop
    
    // Graceful shutdown
    logger.Info().Msg("Shutting down server...")
    
    // Create shutdown context with timeout
    shutdownCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    // Shutdown HTTP server
    if err := httpServer.Shutdown(shutdownCtx); err != nil {
        logger.Fatal().Err(err).Msg("Server shutdown failed")
    }
    
    // Shutdown worker
    if err := workerInstance.Shutdown(shutdownCtx); err != nil {
        logger.Fatal().Err(err).Msg("Worker shutdown failed")
    }
    
    logger.Info().Msg("Server exited properly")
}
#+END_SRC